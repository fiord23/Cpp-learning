//task_12
#include <io.h> // для функции _setmode
#include <fcntl.h> // для константы _O_U16TEXT
#include <iostream>
using namespace std;

// моделируем ту часть памяти компьютера, которая может хранить только
// вещественные числа типа float
const int fm_SIZE = 100; // размер этой части памяти (количество мест для хранения чисел)
float fmemory[fm_SIZE];  // массив, представляющий часть памяти компьютера
int fmem_top = 0;        // следующее свободное место в этой части памяти компьютера

// моделируем ту часть памяти компьютера, которая может хранить только
// адреса (адреса любых значений в памяти компьютера тоже хранятся в памяти)
const int pm_SIZE = 100; // размер этой части памяти (количество мест для хранения адресов)
int pmemory[pm_SIZE];    // массив, представляющий часть памяти компьютера
int pmem_top = 0;        // следующее свободное место в этой части памяти компьютера

class Float // класс, моделирующий переменную типа float
{
private:
	int addr; // адрес в памяти, по которому хранится значение нашей переменной
			  // (в нашей модели это индекс массива, представляющего память компьютера)
public:
	Float(float value)     // конструктор с одним аргументом
	{
		fmemory[fmem_top] = value; // сохраняем значение нашей переменной в «память»
		addr = fmem_top;           // запоминаем «адрес» нашей переменной в «памяти»
		fmem_top++;                // изменяем индекс, указывающий на следующее свободное
								   // место в «памяти»
	}
	int operator& () const // перегрузка операции & получения адреса переменной в памяти
	{
		return addr;
	}
};

class ptrFloat // класс, моделирующий указатель на значение типа float
{
private:
	int addr; // адрес в памяти, по которому хранится значение нашего указателя
			  // (в нашей модели это индекс массива, представляющего память компьютера)
public:
	ptrFloat(int value)      // конструктор с одним аргументом
	{
		pmemory[pmem_top] = value; // сохраняем значение нашего указателя в «память»
		addr = pmem_top;           // запоминаем «адрес» нашего указателя в «памяти»
		pmem_top++;                // изменяем индекс, указывающий на следующее свободное
								   // место в «памяти»
	}
	float& operator* () const // перегрузка операции * разыменования указателя
	{
		return fmemory[pmemory[addr]];
	}
};

int main()
{
	// переключение стандартного потока вывода в формат Юникода
	_setmode(_fileno(stdout), _O_U16TEXT);

	Float var1 = 1.234f; // объявим и инициализируем две «переменные типа Float»
	Float var2 = 5.678f;

	ptrFloat ptr1 = &var1; // объявим два «указателя на значения типа Float»
	ptrFloat ptr2 = &var2; // и инициализируем их «адресами» вышеобъявленных «переменных»

	wcout << L"*ptr1 = " << *ptr1 << endl; // неявно извлечём значения переменных var1 и var2
	wcout << L"*ptr2 = " << *ptr2 << endl << endl; // и покажем их на экране

	*ptr1 = 7.123f; // присвоим новые значения переменным,
	*ptr2 = 8.456f; // на которые указывают указатели ptr1 и ptr2

	wcout << L"*ptr1 = " << *ptr1 << endl; // неявно извлечём значения переменных var1 и var2
	wcout << L"*ptr2 = " << *ptr2 << endl; // и покажем их на экране

	return 0;
}